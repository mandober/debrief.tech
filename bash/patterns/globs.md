# Globs

* bash uses BRE (basic RE) by default, with the option to enable ERE as well.

* When using a glob to match a *filename*, `*` and `?` cannot match a forward slash
  (slash-restriction). e.g. glob `*/bin` matches `foo/bin` but not `/usr/local/bin`

* When globs match *patterns*, they can match a slash (no-slash-restriction)

* After word splitting bash performs filename expansions. 
  Therefore, filenames generated by a glob will not be split further. 

* globs are also used to check if data matches a pattern.


e.g. determining file extension:

```
filename='somefile.jpg'
if [[ $filename = *.jpg ]]; then 
    echo "$filename is a jpeg"
fi
# "somefile.jpg is a jpeg"
```


## Extended Globs

* Extended globs add support for ERE (on top of BRE)
* turned off by default, enable them with: `shopt -s extglob`

ERE support:
* `?(list|list2)` Matches 0 or 1 occurrence of the given patterns.
* `*(list|list2)` Matches 0 or more occurrences of the given patterns.
* `+(list|list2)` Matches 1 or more occurrences of the given patterns.
* `@(list|list2)` Matches 1 of the given patterns.
* `!(list|list2)` Matches anything except one of the given patterns. 

- `@(foo|bar)`	matches either foo or bar. (Union.)
- `*(foo)` 	    matches 0 or more instances of foo. (Closure.)
- `?(foo)` 	    matches 0 or 1 instance of foo. (Like the ? operator in ERE.) 
- `!(foo)` 	    matches anything except foo
- `+(foo)` 	    matches 1 or more occurrences of foo


## Regular Expressions

Regular Expressions
http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04 

Regular Expression patterns that use capturing groups (parentheses) will have their 
captured strings assigned to the BASH_REMATCH variable for later retrieval.
Bash uses the Extended Regular Expression (ERE) dialect.
re='(..)_(..)'; if [[ $LANG =~ $re ]]
re='^\*( >| *Applying |.*\.diff|.*\.patch)'; [[ $var =~ $re ]]

Concatenation 	RE ab matches an input string of ab.
Union 		RE a|b matches an input string of a or an input string of b.
Closure 		RE a* matches a 0 or more times
	 		RE a+ matches a 1 or more times
	 		RE a? matches a 0 or 1 time

RE a[0-9] matches a0 or a1 or ... or a9.
The [...] syntax is called a character class or a bracket expression, and specifies an implicit union (a|b) operation.
The resulting expression matches any single character that falls within the specified class ([abcd]) or range ([a-d]).
RE a[[:digit:]] matches a0 or a1 or ... or a9.
RE [[:alpha:]]0 matches a0 or B0 or ....
[[:space:]] matches any character which is displayed as whitespace (including spaces, tabs, carriage returns, etc.).


Extended Regular Expressions (ERE)
ERE a+		one or more
ERE ab?		zero or one
ERE a{3}		3 x a
ERE a{3,}		at least 3
ERE a{,3}		0-3 of a
ERE a{3,5}		3-5 of a

This is the syntax used by egrep, as well as by Bash's [[ ... =~ ... ]] operator. 
Even particular versions of sed can handle these; mainly GNU sed (with -r) and BSD sed (with -E).

Basic Regular Expressions (BRE)
In BRE syntax, all characters are literal except . [ \ * ^ $
There is no union operator (apart from bracket expressions matching a single character), 
however grouping is supported with \( and \).
\{m,n\} syntax is supported in BRE, and means the same as {m,n} does in ERE.
This is the syntax used by the Unix commands grep and sed.

Perl-Compatible Regular Expressions (PCRE)
Familiar regexp with:
. (any char), ? (0 or 1), + (1 or more), * (zero or more of preceding chars) ...

Extended globs ("extglob")
they have closure, union and grouping operators. 
The syntax is different from that of EREs - extended globs use a prefix notation 
(where the operator appears before its operands), rather than postfix like EREs.
  Extglob @(foo|bar) matches either foo or bar. (Union.)
  Extglob *(foo) matches 0 or more instances of foo. (Closure.)
  Extglob ?(foo) matches 0 or 1 instance of foo. (Like the ? operator in ERE.) 
  Extglob !(foo) matches anything except foo
  Extglob +(foo) matches 1 or more occurrences of foo

In most implementations, regular expressions are not anchored by default. 
This means the expression can match any part of the input string, rather than the entire input string. 
Thus, the BRE abc used in grep (for example) would match the input string abcdefg. 
To act differently, you must specify anchors:
grep '^abc'  ^ start of a line
grep 'xyz$'  $ end of line
grep '^abc$' The expression is anchored at both the start and end of a line.



TESTS
bash param expansion (replacement - delete matching patterns):
a="pera zika pera sima"
echo "${a//+(pera|sima)}"  # " zika"









