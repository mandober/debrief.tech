# Keyboard

**Keyboard**: unicode, line discipline, readline, command-line editing, modifier keys, metafication, function keys, app keys, bracketed paste, ESC key, ALtGr, Alt, Ctrl, Backspace, TAB, Break, SysRq, flow control, canonical mode, cooked mode, entering secrets, login tty, keyboard layout, keyboard mode, locale, CapsLock, swapping keys, key hit, key press, holding a key, releasing a key, typematic rate, media keys, numpad, arrow keys, home row, Supre key, menu (app) key, DEL, Ins, 


## Keyboard as part of the terminal

Any pressed key or keyseq has to go to a bunch of layers before it reaches the intended application started by the (bash) shell running in a terminal emulator.

Pressing a key on the keyboard sends a *scancode* to the CPU. The scancode is generated by the microprocessor embedded in the keyboard which generates the scan codes and distinguishes between the *key press* and *key release*. The software (OS) can then interpret the scancodes according to some mapping. The CPU gets the scancodes via keyboard (input) interrupts, prompting thre CPU to process the scancode and deliver the result to the OS. The scancodes are sent via a serial line (as serial packages), be it a PS/2, USB, Bluetooth or some other connection.

- Keyboard Technology
- keyboard matrix (rows, columns, 3 volt, conntact on intersections)
- 11 cols × 12 rows = 132 keys
- modern keyboards have ~ 104, 105, 110, 111 keys
- scancode
- key press and key release events are distinguished

## Keyboards parts

Modern keyboards are a great technological achievement of a cheap but reliable and fairly durable product. A keyboard is assembled from about 150 parts, with majority being dirt cheap parts like the plastic keycaps, screws, top and bottom plastic casing. There are only a few critical components which include a rubber sheet with domes under each key, and 3 plastic sheets. The top and bottom sheets have conductive wires printed onto them, with carbon conductive dots glued under each key, with the middle sheet acting as a spacer with holes cut out of it. The remaining crucial components include a bracket to clamp down the plastic sheets, a PCB with a simple microprocessor, a crystal oscillator, a switch, and wiring that connects to the wires printed on the top and bottom plastic sheets.

## Keyboards operation

The main idea is that the microprocessor built into the keyboard applies 3 volts to all the traces on the bottom sheet, while it actively monitors all the traces on the top sheet.

When a key is pressed, it presses on the rubber dome, which pushes the conductive circle from the top sheet down through the air gap created by the middle sheet, into the circle on the bottom sheet, thereby completing the connection between the top and bottom plastic sheets.

The change then travels along the conductive trace of the bottom sheet through the hole of the key that has been pressed, and into the top sheet's trace, returning back to the PCB where the microprocessor detects it.

When a key is released, the rubber dome returns the key to the neutral position, thereby breaking the electric circuit.

On the top sheet of plastic are 12 traces, while the bottom sheet has 11 traces, with each trace traveling to a different set of keys.

The traces are organized into a grid, called a *keyboard matrix*, with the bottom traces forming the columns and the top traces forming the rows.

The microprocessor outputs 3 volts along each column while actively monitoring the inputs along each row.

For example, when we press the Y key, the 3 volts are sent out along the 4th column, returning along the 2nd row, and thus the microprocessor can tell that the Y key was pressed. Or, when the B key is pressed, 3 volts are output along  the 8th column, looping back through the 1st row.

With 11 columns and 12 rows, there is a maximum of 132 keys, which is enough for all the standard keys, with a room leftover for a set of media keys.

## Scanning Through the Computer Keyboard

However, there is a major problem with the keyboard matrix as desribed so far: if the same 3 volts are running along all the columns, and we press a key, the 3 volts returns along some row. But because each column is charged with the same 3 volts, how do we determine which row connected?

A costly solution would be to quickly scan (send 3 volts) along each of the 11 columns, so that only one column is active at a time. By correlating the active column with the time the voltage is received on the input row, it would be possible to determine the exact intersection (of column and row), and thus the key that was pressed. However, with this solution, we're continuously scanning 3 volts across the columns, which sucks a lot of power.

https://www.youtube.com/watch?v=h-NM1xSSzHQ&list=TLPQMTAwMTIwMjQLwCgmI9FIFQ&index=4



## ASCII
Pressing a letter-key on the keyboard usually yields that letter (as an input) *encoded using 7 or 8 bits*? The ASCII encoding uses 7 bits - the 8th bit (msb) is not used. It may be repurposed (parity check or something else), but the proper ASCII encoding know only of 7 bits. Using 7 bits means it is possible to represent 2⁷ = 128 distinct values.

␣␣␣ ␣␣␣␣␣
⁸⁷⁶ ⁵⁴³²¹
x00:00000

Looking at the ASCII table, we see that the 128 ASCII characters can be grouped in 4 columns, each with 32 rows. The 4 columns are best represented in binary, as 00, 01, 10, 11. The 32 rows are best represented by 2 hex digits: from 0x00 to 0x1f. Thus, the bits 7 and 6 determine the column (0-3) and the bits 1-5 determine the row (0-31).
