# 2. Lisp Data Types

https://www.gnu.org/software/emacs/manual/html_node/elisp/Lisp-Data-Types.html

- 2.1 Printed Representation and Read Syntax
- 2.2 Special Read Syntax
- 2.3 Comments
- 2.4 Programming Types
  - 2.4.1 Integer Type
  - 2.4.2 Floating-Point Type
  - 2.4.3 Character Type
    - 2.4.3.1 Basic Char Syntax
    - 2.4.3.2 General Escape Syntax
    - 2.4.3.3 Control-Character Syntax
    - 2.4.3.4 Meta-Character Syntax
    - 2.4.3.5 Other Character Modifier Bits
  - 2.4.4 Symbol Type
  - 2.4.5 Sequence Types
  - 2.4.6 Cons Cell and List Types
    - 2.4.6.1 Drawing Lists as Box Diagrams
    - 2.4.6.2 Dotted Pair Notation
    - 2.4.6.3 Association List Type
  - 2.4.7 Array Type
  - 2.4.8 String Type
    - 2.4.8.1 Syntax for Strings
    - 2.4.8.2 Non-ASCII Characters in Strings
    - 2.4.8.3 Nonprinting Characters in Strings
    - 2.4.8.4 Text Properties in Strings
  - 2.4.9 Vector Type
  - 2.4.10 Char-Table Type
  - 2.4.11 Bool-Vector Type
  - 2.4.12 Hash Table Type
  - 2.4.13 Function Type
  - 2.4.14 Macro Type
  - 2.4.15 Primitive Function Type
  - 2.4.16 Byte-Code Function Type
  - 2.4.17 Record Type
  - 2.4.18 Type Descriptors
  - 2.4.19 Autoload Type
  - 2.4.20 Finalizer Type
- 2.5 Editing Types
  - 2.5.1 Buffer Type
  - 2.5.2 Marker Type
  - 2.5.3 Window Type
  - 2.5.4 Frame Type
  - 2.5.5 Terminal Type
  - 2.5.6 Window Configuration Type
  - 2.5.7 Frame Configuration Type
  - 2.5.8 Process Type
  - 2.5.9 Thread Type
  - 2.5.10 Mutex Type
  - 2.5.11 Condition Variable Type
  - 2.5.12 Stream Type
  - 2.5.13 Keymap Type
  - 2.5.14 Overlay Type
  - 2.5.15 Font Type
  - 2.5.16 Xwidget Type
- 2.6 Read Syntax for Circular Objects
- 2.7 Type Predicates
- 2.8 Equality Predicates
- 2.9 Mutability

## 2. Lisp Data Types

A Lisp *object* is a piece of data used and manipulated by Lisp programs.

Every object belongs to at least one type. Objects of the same type have similar structures and may usually be used in the same contexts. 

Types can overlap, and objects can belong to two or more types. Consequently, we can ask whether an object belongs to a particular type, but not for the type of an object.

A few fundamental object types are built into Emacs. These, from which all other types are constructed, are called **primitive types**. 

Each object belongs to one and only one primitive type. These types include:
- integer
- float
- cons
- symbol
- string
- vector
- hash-table
- subr
- byte-code function
- record

plus several special types, such as buffer, that are related to editing.

Each primitive type has a corresponding Lisp function that checks whether an object is a member of that type.

Lisp is unlike many other languages in that its objects are *self-typing*: the primitive type of each object is implicit in the object itself. For example, if an object is a vector, nothing can treat it as a number; Lisp knows it is a vector, not a number.

In most languages, the programmer must declare the data type of each variable, and the type is known by the compiler but not represented in the data. Such type declarations do not exist in Emacs Lisp.

A Lisp variable can have any type of value, and it remembers whatever value you store in it, type and all.

Actually, a small number of Emacs Lisp variables can only take on values of a certain type.

This chapter describes
- purpose
- printed representation
- read syntax
of each of the standard types in GNU Emacs Lisp.

## 2.1 Printed Representation and Read Syntax

The **printed representation** of an object is the format of the output generated by the Lisp printer (the function `prin1`) for that object. 

Every data type has a *unique printed representation*. 

The **read syntax** of an object is the format of the input accepted by the Lisp reader (the function `read`) for that object. This is not necessarily unique; many kinds of object have more than one syntax.

In most cases, an object's printed representation is also a read syntax for the object. However, some types have no read syntax, since it does not make sense to enter objects of these types as constants in a Lisp program. 

These objects are printed in *hash notation*, which consists of the characters `#<`, a descriptive string (typically the type name followed by the name of the object), and a closing `>`. For example:

    (current-buffer)
      ⇒ #<buffer objects.texi>

Hash notation cannot be read at all, so the Lisp reader signals the error `invalid-read-syntax` whenever it encounters `#<`.

In other languages, an expression is text; it has no other form. In Lisp, an *expression is primarily a Lisp object* and only secondarily the text that is the object's read syntax. Often there is no need to emphasize this distinction, but you must keep it in the back of your mind, or you will occasionally be very confused.

When you evaluate an expression interactively, the Lisp interpreter first reads the textual representation of it, producing a Lisp object, and then evaluates that object. However, *evaluation* and *reading* are separate activities.

Reading returns the Lisp object represented by the text that is read; the object may or may not be evaluated later.

## 2.2 Special Read Syntax

https://www.gnu.org/software/emacs/manual/html_node/elisp/Special-Read-Syntax.html

Emacs Lisp represents many special objects and constructs via special *hash notations*:

'#<…>'
Objects that have *no read syntax* are presented like this.

'##'
The printed representation of an *interned symbol* whose name is an empty string.

'#''
This is a *shortcut for function*.

'#:'
The printed representation of an *uninterned symbol* whose name is foo is '#:foo'.

'#N'
When printing circular structures, this construct is used to represent where the structure loops back onto itself, and 'N' is the starting list count:

    (let ((a (list 1)))
      (setcdr a a))
    => (1 . #0)

'#N='
'#N#'
'#N=' gives the name to an object, and '#N#' represents that object, so when reading back the object, they will be the same object instead of copies .

'#xN'
'N' represented as a *hexadecimal* number ('#x2a').

'#oN'
'N' represented as an *octal* number ('#o52').

'#bN'
'N' represented as a *binary* number ('#b101010').

'#(…)'
String *text properties*.

'#^'
A *char table*.

'#s(hash-table …)'
A *hash table*.

'?C'
A *character*.

'#$'
The *current file name* in byte-compiled files. This is not meant to be used in Emacs Lisp source files.

'#@N'
Skip the next 'N' characters. This is used in byte-compiled files, and is not meant to be used in Emacs Lisp source files.

'#f'
Indicates that the following form isn't readable by the Emacs Lisp reader. This is only in text for display purposes (when that would look prettier than alternative ways of indicating an unreadable form) and will never appear in any Lisp file.

## 2.5 Comments
https://www.gnu.org/software/emacs/manual/html_node/elisp/Comments.html

In Lisp, an unescaped semicolon (`;`) starts a comment if it is not within a string or character constant.

The comment continues to the end of line. 

The Lisp reader discards comments; they do not become part of the Lisp objects which represent the program within the Lisp system.

The `#@count` construct, which skips the next count characters, is useful for program-generated comments containing binary data. The Emacs Lisp byte compiler uses this in its output files. It isn't meant for source files, however.

## 2.4 Programming Types
https://www.gnu.org/software/emacs/manual/html_node/elisp/Programming-Types.html

There are 2 general categories of types in Emacs Lisp:
- those having to do with Lisp programming
- those having to do with editing

The former exist in many Lisp implementations, in one form or another. The latter are unique to Emacs Lisp.

- Integer Type
- Floating-Point Type
- Character Type
- Symbol Type
- Sequence Types
- Cons Cell and List Types
- Array Type
- String Type
- Vector Type
- Char-Table Type
- Bool-Vector Type
- Hash Table Type
- Function Type
- Macro Type
- Primitive Function Type
- Byte-Code Function Type
- Record Type
- Type Descriptors
- Autoload Type
- Finalizer Type

### 2.4.1 Integer Type

Under the hood, there are two kinds of integers: 
- small integers, called *fixnums*
- large integers, called *bignums*

The range of values for a fixnum depends on the machine. The minimum range is −536,870,912 to 536,870,911 (*30 bits*; i.e., −2^29 to 2^29 − 1) but many machines provide a wider range.

Bignums can have arbitrary precision. Operations that overflow a fixnum will return a bignum instead.

All numbers can be compared with `eql` or `=`; fixnums can also be compared with `eq`.

To test whether an integer is a fixnum or a bignum, you can compare it to `most-negative-fixnum` and `most-positive-fixnum`, or you can use the convenience predicates `fixnump` and `bignump` on any object.

The read syntax for integers is a sequence of (base ten) digits with an optional sign at the beginning and an optional period at the end. The printed representation produced by the Lisp interpreter never has a leading '+' or a final '.'.

    -1               ; The integer −1.
    1                ; The integer 1.
    1.               ; Also the integer 1.
    +1               ; Also the integer 1.
