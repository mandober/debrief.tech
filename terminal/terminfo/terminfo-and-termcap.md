# terminfo and termcap

In the years since 1985, much has happened: `terminfo` was introduced and `termcap` was greatly expanded. Over 100 capabilities were supported in the 1985 termcap system, vs around 300 in System V `terminfo` and BSD 4.3 `termcap`.

If a program is designed to use termcap or terminfo, it queries an environment variable `TERM` to determine the terminal type, then looks up the entry for that terminal in the terminal database, and reads the definition of any capabilities it plans to use into external variables.

In contrast to the termcap database, which has evolved over the years, the termcap library has remained constant. However, a higher-level subroutine library called `curses` (for "cursor manipulation") was developed to make it easier for programmers to write terminal-independent programs. Programs written with curses use different routines but the same terminal database. The original version of curses was written by Ken Arnold, and is still shipped with BSD systems. The curses library was rewritten and expanded by Mark Horton for System V.

The `terminfo` database is the UNIX System V equivalent to `termcap`, created by Mark Horton. The most important difference between the two systems is that `terminfo` is a compiled database, while `termcap` is a human-readable text database. The terminfo approach improves efficiency, but at the price of accessibility, terminfo has a greater proprogram support superstructure than termcap, but it is not as easy to examine or experiment with.

While the termcap database is contained in a single large ASCII file, terminfo consists of a directory hierarchy of individual compiled terminal descriptions. In order to view or modify an entry, you must decompile it with a program called `infocmp`; to add an entry, you must write and compile it with `tic`, the terminfo compiler, before you can use it. This makes it more difficult to incrementally test a new entry.

While the capabilities described in both databases are equivalent for the most part, only a few of the *capability names* are the same, `termcap` allows only 2 characters for capability names, while `terminfo` uses up to 5 characters. Furthermore, the syntax for encoding some of the more complex capabilities is different.

An important point is that not all programs use `terminfo` or `termcap`, and that there are several other mechanisms that may also affect terminal operation.

The operation of the serial interface is controlled by several system files (/etc/ttys and /etc/gettytab on *BSD and other non-AT&T systems*, and /etc/inittab and /etc/gettydefs in *System V*).

Users can affect serial line parameters with the `stty` command. In addition to normal communications parameters such as baud rate, start and stop bits, parity, and so on, these parameters include such things as the translation of the carriage returns generated by most terminals into the linefeeds expected by most programs, division of input into lines, and definition of special control characters for erasing a character that has been typed, killing a line of typed input, and key combo for interrupting a running process.

One other area that termcap and terminfo do not control is terminal tab setting. This is done by the `tabs` command. For more information, see the man pages on stty and termio (Sys V).

termcap and terminfo, by contrast, tend to control visual attributes of the terminal. The terminal capabilities defined for a terminal tell a screen-oriented program how big the screen is (for screen-by-screen paging and cursor-movement), how to move to any point on the screen, how to refresh the screen, how to enter and exit any special display modes (such as inverse video, blinking, or underlining), and so on.

But there is some overlap. For example, a terminal can be unusable because a program has left either the serial line modes or the terminal itself in an unexpected state. For this reason, terminal initialization, as performed by the `tset` and `tput` programs initializes both the terminal and the serial line interface.

## Reading termcap and terminfo entries

`termcap` terminal database is stored in the single file `/etc/termcap`. It is an ASCII file: all the information it contains is readable, if not immediately comprehensible. Each entry consists of a list of names for the terminal, followed by a list of the terminal's capabilities.

The compiled `terminfo` database is stored in a directory hierarchy under `/usr/lib/terminfo`. Each terminal entry is compiled (by a program called `tic`) and stored in a separate file. Entries can be decompiled and displayed with `infocmp`.

A program that wants to make use of the terminal capability database selects an entry according to the value of the `TERM` environment variable. This variable is typically set when a user logs in. A second variable, either `TERMCAP` or `TERMINFO`, may also be set, if it is desirable to point to a terminal description that is not in the standard location.

In termcap, the first line of each entry shows several different names, or aliases, for the terminal. At least one of the names will usually reflect the manufacturer's shorthand name for the terminal, but a long name is usually included as well, so you can simply search for the manufacturer's name to get started.

In the case of terminfo, there will be a separate filename for each terminal alias. You can use any of the equivalent aliases.

Use the following command to print out the long name of the terminal:

```bash
tput -Txterm-256color longname
#: xterm with 256 colors
tput -Txterm-24 longname
#: xterm terminal emulator (X Window System)
tput -Txterm.js longname
#: Visual Studio Code terminal using xterm.js
```

For terminals with configurable options (such as a terminal with an 80 or 132 column mode), there may be several termcap or terminfo entries.

terminfo uses comma as a field separator.

The second line is a list of alias names for the terminal, separated by pipes. Multiple aliases are provided as a convenience to the user. The environment variable TERM can be set to any one of the aliases. By convention, the last alias is the full name of the terminal. The alias list is the first field of the terminal description, with a colon (termcap) or comma (terminfo) marking the end of the alias list and the start of the capabilities list.

When a terminfo source file is compiled with `tic`, the compiled data is placed in a file corresponding to the first alias, and a link is created for all other aliases but the last.

There are 3 types of capability:
- **Boolean capabilities** consist of a capability name with no arguments. For example, `am` (both termcap and terminfo) specifies that the terminal performs *automatic (right) margins*, wrapping the cursor to the start of the next line when the cursor reaches the last position on the current line. If `am` is not specified, programs will assume that your terminal does not have this feature. Booleans also specify negative features, e.g. if your terminal does not perform newlines in the expected way, you might have what is called the "newline glitch", and you may need to specify `xenl` to tell programs about it.

- **Numeric capabilities** consist of a capability name, a hash sign, and a number. For example, `cols#80` says that the terminal has 80 columns. Numeric values are non-negative.

- **String capabilities** tell how to issue a command to the terminal. The format of a string capability is the capability name followed by an equals sign followed by the command sequence. For example, `cuul=AK` specifies that the sequence C-k will move the cursor up one line.


## Encoding arguments

`cup` specifies the cursor motion capability, which describes how to move the cursor directly to a specific location. Since the desired location is specified by the program at run time, the capability must provide some mechanism for encoding arguments. The program uses this description to figure out what string it needs to send to move the cursor to the desired location.

Tthe percent sign is used for encoding, and when it appears in a terminal entry, the capability is using run time parameters.

## Terminal Naming Conventions

The naming convention for `terminfo` is slightly different than for termcap. The first terminfo name is the most common abbreviation for the terminal. The last terminfo name is the verbose, fully descriptive name of the terminal. All other names for the terminal are put in between. There are a few additional conventions: All names should be unique, only the last, verbose name should contain spaces, and terminal names should not include a dash except when using terminal flags. In terminfo, names for entries that are only for use by other entries through the terminfo `use=` capability should contain a "+" sign in their name.

Many terminals can be set up to run in different modes with hardware or software options. You can write different terminal entries for the different setup options and issue the software commands to configure the terminal that way in the initialization capabilities.

The naming convention for terminals with varying setup options uses *flags separated by hyphens to identify set options*. For example, the Digital vt100 set to use wide mode uses the name "vt100-w".

There are some conventions that are followed in using flags for *hardware setup modes*. The standard suffix flags are:

- `-am` Terminal is set up to perform automatic margins
- `-nam` Terminal is set up so that it does not perform automatic margins
- `-w` Terminal is set up in wide mode (more than usual number of columns)

- `-rv` Terminal is set up in *reverse video* mode. Normal output is output in reverse video mode, and output specified as reverse video is output in normal mode.

- `-na` Terminal is set up with "no arrows", i.e. numpad is put into local mode

- `-s` Terminal is set up with *status line*. This is for terminals which can take one or more lines, normally part of the screen proper, and use them for status. It is not for terminals which have permanently dedicated status lines which can be turned off and on.

- `-{N}` Terminal is set up to operate with `{N}` lines only. For example, some termoses can be configured to run between 20 and 60 lines, using smaller characters when using more lines. Users have their own preferences, probably based on the acuity of their eyesight.

- `-{N}p` Terminal has `{N}` *pages* of screen memory set up as hardware option

- `-unk` Terminal has "unknown" modes. The entry is for the general description of a terminal which has several of the other modes described above. Those entries can then use the equivalent terminal capability to read in this generic description and add their own customizations. Those entries would then have their own specific naming flags.

When writing entries, you may find it necessary to make up your own flags, depending on your terminals. The flags should not describe the terminal in full - that is the purpose of the entry itself. They are only for distinguishing different setup options of a single model.

If more than one flag applies, concatenate them together. The dashes between flags are sometimes, but not always, dropped. Provide alias names with the flags in either order so that the user does not have to remember the order of the flags. An example of a name line that shows an alias with multiple flags is:

    vtl00-w-nam|vtl00-nam-w|…

## Padding

Some terminals need time to digest certain commands: they cannot receive further output from a program until they finish processing the current output.

This extra time is called padding. Programs pad commands by sending an appropriate number of "no-op" characters (usually the null character). These "no-ops" are ignored, giving the terminal time to complete the command.

Adding redundant padding will never hurt - it will just slow down the display by the specified amount.

`termcap` indicates padding by specifying the delay time in ms after the equal sign and before the command code in a string capability. For example, `ho=10^^` would indicate a delay of 10 ms after the cursor is moved to the home position with `^^` command. It is also possible to specify proportional padding, which means that the delay should be applied to each line that is affected. This is done by following the padding value with an asterisk. For example, if the clear screen capability were specified as `cl=5.5*^Z` on a 24 line screen, a wait of 5.5 × 24 = 132 ms occurs after ^Z is sent to allow the screen to clear. One place of precision is allowed for proportional padding. If an integer value is specified, the decimal point can be omitted. In termcap, the padding is always output after the string.

In `terminfo`, padding is written `$<n*>`, where `n` is the amount of padding and `*` is an optional flag indicating proportional padding.

*Proportional padding* in terminfo works identical to the way it does in termcap: it is represented by the asterisk and the delay will be applied to each line.

If clear capability were `clear=^Z` on a 24-line screen, a wait of 5.5×24=132ms occurs after `^Z` is sent to clear the line. Thus, an example of padded capabilities might be: `clear=^Z$<5.5*>` and `home=^^$<10>`.

The `$<pad>` bracket can be put anywhere in the terminfo capability. The padding will be transmitted at that point within the string. Since the padding is usually desired after a sequence, the padding is thus usually placed at the end of the capability.

Sometimes it makes more sense elsewhere. For example, a clear screen capability may be created using two escape sequences: ESC-H to move the home position, which requires a 20ms pad; and ESC-L to clear from there to the end of the screen, which requires a 30ms pad. In terminfo, the padding is kept where it belongs, `clear=\EH$<20>\EL$<30>`, and will be subsequently output at the correct time.

*Mandatory padding* is a feature of terminfo, where the `/` character can be included in a padding specifications to indicate "mandatory padding." Mandatory padding is padding which is sent even when the terminal is in XON/XOFF mode. For example, we could have specified: `clear=^Z$<5.5*/>`, `home=^^$<10/>`.

terminfo uses `pad` capability to specify the *padding character* to use instead of the null character. Many terminals use a delete character (octal 177) instead.

terminfo also supports `npc` (no pad char) to say there is *no pad character* that cab be used as a pad character.

## Encoding runtime arguments

terminfo's `cup` is for cursor motion capabilities, which describe how to move the cursor directly to a specific location. Since the desired location is specified by the program at run time, the capability must provide some mechanism for describing arguments. The program uses this description to figure out what string it needs to send to move the cursor to the desired location.

Other capabilities that require run time parameters include
- parameterized line deletion (delete a run time-specified number of lines)
- changing the scrolling region (scroll only part of screen between two lines)
- programming function keys (program a function key to send a specified string)
- setting windows (set a window on the screen between two rows and two columns)

An important distinction that deserves emphasis is that *simple string capabilities* tell what string to send, while *string capabilities with arguments* tell the program how to calculate what string to send.

The cursor movement capability 
- in termcap, `cm=\E=%+ %+ :`
- in terminfo, `cup=\E=%p1%'\s'%+%c%p2%'\s'%+%c`, i.e.

    cup = \E = %p1 %'\s' %+ %c 
               %p2 %'\s' %+ %c

- `\E`    means ESC
- `%p1`   Probably means param#1
- `%p2`   Probably means param#2
- `%'\s'` Probably encodes a space
- `%c`    Probably means a char
- `%+`    Probably means concat

The termcap and terminfo strings are quite different! They contain the
same information, but they have different syntaxes for describing run
time arguments. The terminfo syntax is much more complicated than
the termcap syntax, so we will examine the termcap cm= capability
first.

### Parameters in Termcap

`cm=\E=%+ %+ :`

`\E` is the ESCAPE character, and `%+ %+ ` is the cryptic description of the next two characters to send:
- the first to set the row
- the second to set the column

The first `%+⎵` says to add the desired row number (symbolized as `%`, and based on the top left corner being row 0, column 0) to the ASCII value of the SPACE character, `%+⎵`. The resulting number will be taken as the ASCII value of the character that will move to the specified row. The second `%+⎵` says to do the same for the desired column.

For example, if you wanted to move to row 6, column 18, the program would send the 4 character sequence `ESC=&2`. The program calculates this by figuring out that `ord(" ") = 32`, the 32 + 6 (rows) = 38, and `chr(38) = &`. Similarly, 32 + 18 (cols) = 50, and `chr(50) = 2`.

The example demonstrates the `%+` escape sequence, but there are many more escape sequences available for encoding arguments in a termcap file, all using the character `%`.

The `%` escapes are grouped into 3 classes:
- %-escapes that modify how later `%` escapes are interpreted
- %-escapes that, subject to those modifications, actually send the row or column value (encoded)
- %%-escape, which simply sends the `%` character

The `%` argument encoding instructions in termcap

Output Operations:
- `%d` Send a value as a decimal number
- `%2` Send a value as a two-digit decimal number
- `%3` Send a value as a three-digit decimal number
- `%.` Send the corresponding ASCII character value
- `%+c` Add `ord(c)` to the value, `val`, and send the ASCII char that corresponds to their sum; i.e. `chr(ord(c) + val)`
- `%%` Send a literal percent sign

Interpretation Modifiers:
- `%r` Reverse the order of args for `cm=` or `cs=`. The default is row before column, and start scrolling region before end scrolling region.
- `%i` Increment the values given by one. Used for terminals that have home at (1,1) rather than (0,0).
- `%>x,y` If the value is greater than the ASCII value of `x`, add the ASCII value of `y` to the value (rarely used).

Special Cases:
- `%n` XOR the values with 01400 before using the following %-escapes to send.
- `%B` Change the next value to binary coded decimal, 
       `16 * x/10 + rem(x/10)`, where `x` is the value.
- `%D` The next value is reverse coded `x - 2*(rem(x/16))`, 
       where `x` is the value.

```
x=123

bcd x = 16 * (x / 10) + rem (x / 10)
      = 16 * (123 / 10) + rem (123 / 10)
      = 16 * 12.3 + 3
      = 196.8 + 3
      = 199.8

x - 2 * rem (x / 16)

= 123 - 2 * (rem(123/16))
= 123 - 2 * 11
= 123 - 22
= 101


n / m = (q, r)
n = mq + r
123 = 10 * 12 + 3 = 120 + 3 = 123
```
